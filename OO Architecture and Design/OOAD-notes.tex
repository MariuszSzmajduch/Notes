\documentclass{report}
\title{latex-notes}

\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{hyperref}
\usepackage{tabto}

\begin{document}
\pagenumbering{gobble}
\tableofcontents

\pagenumbering{arabic}




\part{Resources}

\begin{itemize}
	\item UML Distilled textbook by Martin Fowler 
	\item Object-Oriented Software Engineering Practical Software Development
	using UML and Java (second ed.), Lethbridge, Laganiere
	\item Head First Object Oriented Analysis and Design, McLaughlin, Pollice, West
	\item Head First Design Patterns, Freeman, Freeman 
\end{itemize}




\part{Paradigmes}



\chapter{Abstraction}
There are different meanning of abstractin. one of them is the ability to capture real world entities as classes.
Two types of abstractions in Java:
\begin{itemize}
	\item \textbf{interfaces}, used to define expected behaviour.Implementation \textbf{is hidden from a client}.
	\item \textbf{abstract classes}, used to define incomplete functionality.
\end{itemize}



\chapter{Inheritance}
The ability of subclass to derive members (fields and methods) from ascendands. In java only single parent class is allowed. It is an \textbf{'is-a'} relationship.
\textbf{Derived class inherits all members present in the base class. 
However not all of them are accessible}. This is ruled by access modifiers used in the base class.


\section{Accessing Members}
It is valid to instantiate an object with a subtype. The instantiated reference variable allows an access to those members (and their variations) which are present in their type.
It is still possible to access subtype members using cast:
\begin{verbatim}
Parent childParent = new Child();
\\ access to a member as it is defined in the Parent class.
childParent.field... 

\\ access to a member as it is defined in the Child class
((Child)childParent).field 
\end{verbatim}
\textbf{\textcolor{red}{Pay attention to the syntax of above cast!}}
%
%\begin{tabular}{i|l|l|l}
%	types & fields & cast & method calls \\
%	\hline
%	Parent pc = new Child() & parent & \textbf{to child} & \textbf{child \textcolor{red}{(*)}}\\
%	Parent p = new Parent() & parent & \textcolor{red}{\textbf{error!} & parent} \\
%	Child c = new Child() & child & \textbf{to parent} & child \\
%	Child c = new Parent() & \textcolor{red}{\textbf{error!}} & &\\
%	\hline
%\end{tabular}\\

\par
\textbf{\textcolor{red}{*  Those method which are overridden are accessible as usual.\\
In order to call methods that are not overridden the reference variable 
used to access the methods (here - \textit{pc}) must be cast to (Child)}}


\section{Pitfalls}

\subsection{Constructor Calls an Overridable Method}
\begin{enumerate}
	\item call to constructor in \textbf{child class}
	\item it calls \textbf{parent class constructor} first
	\item if there is a call to overridable method it calls \textcolor{red}{\textbf{textchild version of the method}}
	\item \textbf{ERROR! }The call \textcolor{red}{\textbf{will fail}} if the method references some uninitialised variable.
	\textcolor{red}{\textbf{The variable can be initialised only when the control returns to child constructor - in steps which will folow!}}
\end{enumerate}


\section{Liskov Substitution Principle}
Whenever an instance of some class is expected in a program, 
one can suply an instance  of subclass of the class



\chapter{Encapsulation}
Inner details of classes can be hidden by making them private and acceptible
through public API only - getters (accessors) and setters (mutators).



\chapter{Polymorphism , Method Overriding}
\textit{'Many forms'}. implemented by
\begin{itemize}
	\item subclass specialisation (\textit{is-a'} relationship
	\item Liskov substitution principle
	\item virtual method invocation)
\end{itemize}
Polymorphism is usually achieved by method overriding. It utilises method dynamic binding.


\section{Virtual method Invocation}
Method calls are dynamically dispatched based on runtime type of the receiver object.


\section{Method Overloading}
Overloading means that two or more methods have the same name
 but different signature. They \textbf{must have different parameters} (number of them and/or types),
 they \textbf{may have different return type and access modifiers} (private, protected, etc) - see Rules.
 
 
\section{Method Overriding}
It means that new implementation is provided to an inherited method. This is annotated by @Override. The overridden method in a superclass can be still called 
when invoked using \textbf{super.} keyword.

\subsection*{Rules}
\begin{itemize}
	\item \textbf{final, static, private} methods can't be overridden.
	\item access modifier of overriding method \textbf{must not be more restrictive}.
	\item \textbf{no new checked exception} can be thrown
	\item if return type is a reference type, then it can be original type or any descendant of this type (\textbf{covariant return type}).
\end{itemize}

\textbf{Private} methods can't be overriden because they are excluded from inheritance (not visible from within subclasses). \\
\textbf{Static} methods reside in static context, they belong to class, not to objects. Therefore they are not inherited, too. Hence, they can't be overriden. \\
However, they can be \textbf{shadowed} - subclass can have static method with the same name, as its parent class. A method call is bind to first method with a proper signature - starting 
from the class in current context and going up the inheritance tree.




\part{Design Principles}



\chapter{Separate What Vary from What Stays the Same}
Extracting changing parts and encapsulating them separatly allows future//
changes without affecting existing parts of code.



\chapter{Program to an Interface, not an Implementation}
Here by 'an interface' an API is meant, not the java.



\chapter{Favour Composition over Inheritance}
Allows dynamic changes of behaviour in runtime. See: Strategy Pattern.



\chapter{Strive for loosly coupled designs between objects that interact}
Loosely coupled designs allow us to build flexible OO systems that can handle change 
because they minimize the interdependency between objects.




\part{Design}



\chapter{Requiremments}


\section{Use Cases}





\part{Creational Patterns}

Those patterns specify how an object can be created.


\chapter{Singleton}

\section{Problem Descritpion}
All cases, when \textbf{exactly one instance} is required:
\begin{itemize}
	\item network session
	\item solar system, Milky Way
\end{itemize}
There is a modification to the pattern possible to create a pool of fixed amount of objects.

\section{Implementation}
The key is to:
\begin{itemize}
	\item make the \textbf{class final}
	\item make the \textbf{constructor private}. \textbf{\textcolor{red}{The constructor is mandatory!}} Without it default 'package-protected'
	constructor will be created.
	\item \textbf{static} \textit{object} variable and its \textbf{static} \textit{getter}
	\item \textbf{static getter} returning new object only if there is no object present
\end{itemize}

\begin{verbatim}
final class Singleton{
  // private & static instance variable.
  private static Singleton obj;

  // private constructor
  private Singleton(..){
    ...
  }

  // the only publicly exposed member - instance getter
  public static Singleton getObj(){
    return obj == null? new Singleton() : obj;
  }
}
\end{verbatim}

Object getter is the only publicly exposed API. It returns private static instance variable holding the singleon object. If the object is null, it calls private constructor. There is no other way to call the constructor (and to instantiate another object).

\textbf{final} class modifier is added in order to prevent pattern break by subclassing. Without the keyword it would bo possible to subclass and implement Cloneable interface.
The final modifier prevents singleton from clonning.



\part{Structural}
The way the objects are connected. It allows to implement particular project constraints. The overall idea is to implement such solutions
that future changes to the system won't require changes to existing code.


\chapter{Decorator}
This is a use of layered objects to dynamically and transparently add responsibilities to individual objects. They preserve
original API - we use them by invoking exacty the same methods. Decorator classes just adjust and modify existing interface.
It is often used when large number of subclasses is required to solve al possibilities, like for instance servicing IO
operations. The drawback is that we must to creat multiple objects in order to get single functionality we need.




\part{Behavioural Patterns}
Those patterns capture particular types of actions within a program.



\chapter{Observer}


\section{Problem Description}
The requirement is that objects update their state in respond to changes which occur in some other object. As it is common problem
the solution is supported by standard Java libraries - \textbf{Observer} and \textbf{Observable}.


\section{Implementation}
\begin{itemize}
	\item \textbf{Observable} class 
	\begin{itemize}
		\item \textbf{keeps track} of all objects which need to be notified about the changes which are of their interest
		\item \textbf{notifies} observing objects when the changes happen
		\item We need a call to \textbf{setChanged()} somewhere in the \textit{Observable} class in order to update the flag indicating that a change has happened.
		\textbf{notify()} tests the flag to decide whether \textit{Observers} have to be notified or not. That is the reason why we \textbf{\textcolor{red}{must not just instantiate an object of \textit{Observeable} class, we must extend this class}}
	\end{itemize}

	\item \textbf{Observer} class. Objects of this class \textbf{registers} by Observable in order to be \textbf{updated}
	when some specific change occurs.
\end{itemize}

\begin{verbatim}
  class ObserverableClass extends Observabe{
    
    ...
    
    public void notify(Observer o){
      setChanged();
      super.notify(b);     \\ or implement own way to notify
    }
  }
  
  class ObserverClas implements Observer{
    Observable notifier;
    
    ...
    
    public void register(){
      notifier.addObserver(this);
    }
    
    public void update(ObservableClass oc){
      ...
    }
  }
\end{verbatim}



\chapter{Strategy}


\section{Problem Description}
Derived classes cherrypick behaviours(algorithms). Adding new behaviour in the parent class results
that unwanted behaviour may appear in some child classes. 
 
 
\section{Anti-Patterns}

\subsection{Voiding by Overriding with Empty Methods}
\begin{enumerate}
  \item code duplication (many empty methods)
  \item need to go over all subclasses each time new feature is added.
\end{enumerate}

\subsection{Tag Subclasses with Interfaces}
Another maintenance nightmare:
\begin{enumerate}
  \item terrible code duplication, extremaly bug-proned.
\end{enumerate}


\section{Impementation}
\begin{enumerate}
  \item apply 'separate what vary from what stays the same' principle - extract away optional features.
  \item apply 'favour composition over inheritance' principle - root each tree of extracted features with an
  interface.
  \item apply 'program to interface, not to implementation' principle - assign extracted behaviour as an 
  interface type to allow behaviour change in runtime.
\end{enumerate}

\end{document}