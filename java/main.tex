\documentclass{report}

\title{java-notes}

\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{hyperref}

\begin{document}
\pagenumbering{gobble}
\tableofcontents



\chapter{TODOs}
\begin{itemize}
	\item \textit{Java 8 Lambdas} continue from 'Chapter 7'
	\item \textit{Java Pocket guide} continue from  'Reference Types'
	\item why inner classes (also lambda) require externa values  to be immutable (final in java)
	\item specify methods of all core functional interfaces
	\item check .get(), .sorted(), forEach(a $\rightarrow$ doSth()).
	\item find more about 'primitive type specialisation
	\item 'interfaces, unlike classes, don't have instance fields. Therefore the only way to modify child classes is to call methods on them.' - investigate it!
	\item static methods i interfaces, like Stream.of()
	\item  optional as a replacement for null, p. 55 - 56 in 'Java8 Lambdas' book; applications
	\item test method refereces, including constructors
	\item some operations are more expensive on ordered colections...???
	\item documentation for minBy and maxBy (\textit{Collectors} library),another method in that class, implementations in real codes
	\item Entry, entrySet() in javadoc
	\item IntStream
	\item mapToObj()
	\item check signature of Arrays.parallelSort, Arrays.parallelSetAll, Arrays.parallelPrefix, and update 'DataParalelism'Arrays'
	\item \textit{Test-Driven Development} by Kent Beck
	\item \textit{Growing Object-Oriented Software, Guided by Tests} by Steve Freeman and Nat Pryce 
	\item factory methods in concurrent context
	\item why forced autoboxing/unboxing is not recommended
	\item check recommendation to use final variables on \textit{javapractices}, lec.4
\end{itemize}

\chapter{Use It Later}
\begin{itemize}
	\item abstract classes vs interfaces\\
	- abstract classes let inherit fields, prevent multiple inheritance\\
	- interfaces allows multiple inheritance, have no fields (no states)
	\item Compact Strings
The compact strings feature is an optimization that allows for a more space-efficient internal representation of strings. It is enabled by default in Java 9. This feature may be disabled by using -XX:-CompactStrings, if you are mainly using UTF-16 strings.
\end{itemize}

\chapter{Resources}
Notes based on:
\begin{itemize}
	\item UoG java labs \& classes
	\item \textit{Java 8 Lambdas}, R. Warburton
	\item \textit{Java Pocket Guide},  R. Liguori, P. Liguori
\end{itemize}

\chapter{Basics}
\pagenumbering{arabic}

\section{Overview}

\begin{itemize}
\item object oriented

\item platform-neutral (due to JVM), 'write-once-run-anywhere' philosophy
\begin{quote}
\textbf{.java} (source code) $$ \textbf{.class} (bytecode) $$ (executable)
\end{quote}
\item statically typed (determined in compile-time)
\end{itemize}

\section{Identifiers}
\begin{itemize}
\item starts with letters or underscores
\item composed of letters, underscores or numbers
\item informal naming conventions:
\begin{itemize}
\item initial capital letter for \textbf{classes, interfaces, enums, annotation} names. interfaces should be \textbf{adjectives}.
\item all-CAPS for \textbf{constant identifiers}
\item all lower letters for \textbf{packages modules}. Modules names should be the inverse internet domain name.
\item initial lower case for other identifiers
\item camel-case for multi-word identifiers
\end{itemize}
\end{itemize}

\subsection*{Informal Single-Letter Local Variables Naming}
\begin{itemize}
	\item \textbf{b}, byte
	\item \textbf{i, j, k}, integer
	\item \textbf{l}, long
	\item \textbf{f}, float
	\item \textbf{d}, double
	\item \textbf{c}, character
	\item  \textbf{s}, String
	\item \textbf{o}, Object
	\item \textbf{e}, exception
\end{itemize}

\subsection{Scope Rules}
Block - part of code enclosed by a pair of corresponding curly brackets. Rules:
\begin{itemize}
\item A local variable is in scope from the point if its declaration to the end of the enclosing block.
\item Method parameters are valid until the end of the method.
\item iteration variables declared in a for-loop initializer are in scope until the end of the loop body.
\end{itemize}
\subsection{Name Conflicts.}
No two variables of the same scope and the same type can share the same identifier. However, variables in nested scope shadow the variable with the same identifier and type from enclosing scope. For instance, if global variable and local variable have the same identifier and type, then the value of local variable is used in local scope.
\begin{verbatim}
class MyClass{
int a = 1;
	void print(){
		int a = 2;
        System.out.println(a);
	}
}
\end{verbatim}
displays '2'.

\section{Primitive Types}
Since java is statically typed language types must be:
\begin{itemize}
\item declared:
\begin{verbatim}
int var;
\end{verbatim}
\item ...then initialised with a value before use:
\begin{verbatim}
var = 5;
\end{verbatim}
\item It can be done in one go:
\begin{verbatim}
int var = 5;
\end{verbatim}
\end{itemize}

\subsection{List of Types}
\begin{itemize}
\item integer values
\begin{itemize}
\item expressed as decimals, octals \textcolor{red}{0..}, hex-decimals \textcolor{red}{0x..}, binaries \textcolor{red}{0b1001101..}
\item byte $\rightarrow$ short $\rightarrow$ int $\rightarrow$ long \textcolor{red}{..L}
\item 8-bit $\rightarrow$ 64-bit
\end{itemize}

\item floating point values
\begin{itemize}
\item float, 32-bit, \textcolor{red}{0,0F, 0,0f)}
\item double, 64-bit, \textcolor{red}{0,0D, 0,0d)}
\item \textbf{\textcolor{red}{fractional part not reqiured when type suffix is applied)}}
\end{itemize}

\item boolean, 1-bit flag

\item char, 16-bit (2 bytes) Unicode values
\end{itemize}

\subsection{Conversion}
Specification:\\
\url{https://docs.oracle.com/javase/specs/jls/se9/html/jls-5.html}\\
\par
Implicit conversion - generally widening conversions, where little or no information is lost. Examples - byte to short, int to double, int to long.\\
Narrowing conversion - requires use of explicit cast operator. This conversion is done by truncation of excessive bits. Therefore, it can cause loss  of information:
\begin{itemize}
\item Conversion of integer values:
\begin{verbatim}
int a = 1025;
byte b = (byte)a;
\end{verbatim}
In the example above '1' is assigned to 'b'\\
- '0000..10 0000 0001' is truncated to '0000 0001'.
\item Float to integer conversion:
\end{itemize}
\subsection{Primitive Type Specialisation (from java8)}
The use of boxed numbers creates overheads:
\begin{itemize}
	\item memory overhead, object require additional metadata to be stored in heap
	\item time overhead (for memory allocation)
\end{itemize}

\subsubsection*{Naming Conventions}
\begin{itemize}
	\item interface \textbf{return} type is primitive $\rightarrow$ To\textit{Type}Function\\
	\textit{ToIntFunction, ToLongFunction..}
	\item \textbf{parameter} type is primitivenction $\rightarrow$ \textit{Type}Function\\
	\textit{IntFunction, LongFunction..}
	\item \textbf{higher-order function} using primitive type $\rightarrow$ \textit{Function}To\textit{Type}\\
	\textit{MapToLong..}
	\item \textbf{streams} $\rightarrow$ look 'Aggregate Operations/Specialised Primitive Types'
\end{itemize}

\section{Switch Statement}
\begin{verbatim}
switch(some){
  case x:
    do-sth;
    break; \\ control flows to the next case when there's no break 
  case y:
    do-sth;
    ....
  \\ optionally
  default:
    do-sth;
    break;
}
\end{verbatim}
The use of 'default' makes a code less error prone.

\section{Text-based User Input}
\begin{itemize}
\item program input argument
\begin{verbatim}
public static void main (String[] args){
	String a = args[0];
    String b = args[1];
    ...
}
\end{verbatim}
\item using scanner - \url{https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html}
\end{itemize}

\chapter{Advanced Topics}
\section{Default Methods}
Introduced to java o preserve \textbf{backward binary compatibility}. it means, that programs compiled in previous java version will still compile in new java versions. \textbf{Default methods} are a solution to maintain backward binary compatibility after streaming methods were added to Collections. Those methods provide Collection descendants (without stream methods) whith missing methods.
\subsection*{Inheritance Rules}
Generally - \textbf{class methods wins over interface (default) methods}. Otherwise - standard overriding rules.
\subsubsection*{\textbf{ATTENTION!}}
Generally wen w've got interface reference to soe class, we're interested only on this part of class API which is defined by the interface (which the class must inherit):
\begin{verbatim}
SomeInterface si = new ClassImplement();
\end{verbatim}
Here \textit{si} references only the methods which are specified by underlying interface.
But:
\begin{verbatim}
ChildInterface ci = new ChildClass();
\end{verbatim}
The same default method ParentInterface is overrided by ChildInterface \textit{(which is the most specific)} and ParentClass. \textbf{ParentClass has a priority} over ChildInterface! This prevents default methods from breaking existing inheritance trees in older libraries.

\subsubsection{Multiple inheritance (from multiple interfaces)}
If a method can be inherited from more than 1 interface default method - \textbf{compile error!}. To solve:\\
- \textbf{specify the interface to inherit from} using keyword \textit{super}:
\begin{verbatim}
SomeClass implements Interface1, Interface2{
  @Override
  void defaultMethod(){
    return InterfaceX.super.defaultMethod();
  }
}
\end{verbatim}

Keyword \textit{super} can be used to address parent class API, but to address implemented interface API as well

\chapter{Lambda Expressions}
\section{Motivation}
Abstraction in OOP is an abstraction over data. Lambda expressions add an abstraction over beaviour.\\
Functional programming - problem domains expressed in term of \textbf{immutable} values \& functions that translate between them. 

\section{Lambda Expressions - Overview}
\begin{itemize}
	\item nameless method
	\item intended to pass around behaviour
	\item \textbf{allows to call method direct on interfaces}.
\end{itemize}
Traditionally, behaviour is wrapped into an inner class in order to send - \textbf{code as data}. A class has to implement a functional interface.\\
In lambda expression, we don't have to provide types explicitly.They are inferred from a context - a signature of the method in corresponding functional interface.\\
\textbf{Lambda expressions are statically typed!}
\par \textbf{Every time an object implementing functional interface is in use - as method parameter or return value, lambda expression can be used insted.}

\subsection*{Examples}

\begin{itemize}
	\item no argument, no return
	\begin{verbatim}
	FuncIt fi = () -> ();
	\end{verbatim}
	
	Example:
	\begin{verbatim}
	Runnable noArgument = () -> System.out.rintln("this lambda takes no argument");
	\end{verbatim}
	-----------------------------------------------------------------------------
	\item no argument, 1 return
	\begin{verbatim}
		FuncInt fi = () -> a;
	\end{verbatim}
	-----------------------------------------------------------------------------
	
	\item 1 argument, no return
	\begin{verbatim}
	  FuncInt fi = () -> a;	
	\end{verbatim}
	Example:
	\begin{verbatim}
	ActionListener oneArgument = event - > System.out.println("this is an event"); 
	\end{verbatim}
		-----------------------------------------------------------------------------
	
	\item no arguments, 2 returns
	\begin{verbatim}
		FuncInt fi = () -> {
										do1();
										do2()
										}
	\end{verbatim}
	Example:
	\begin{verbatim}
	Runnable multiStatement = () -> {
		System.out.println("Multi-return);
		System.out.println("lambda expression");
		}
	\end{verbatim}
	-----------------------------------------------------------------------------
	
	\item 1 argument, 1 return
	\begin{verbatim}
		FuncInt fi = (a) -> b;
	\end{verbatim}
		-----------------------------------------------------------------------------
	\item 2 arguments
	\begin{verbatim}
		FuncInt<Long> fi = (a, b) -> a + b;
	\end{verbatim}
	Example:
	\begin{verbatim}
	BinaryOperator<Long> add = (x, y) -> x + y;
	\end{verbatim}
	
	the same with explicit types:
	\begin{verbatim}
		FuncInt<Long> fi = (Long a, Long b) -> a + b;
	\end{verbatim}
	Example:
	\begin{verbatim}
	BinaryOperator<Long> add = (Long x, Long y) -> x + y;
	\end{verbatim}
\end{itemize}

\section{Target Type, Type Inference}

The type of an expression is define by the context in which lambda appears:
\begin{itemize}
	\item method parameter
	\item variable assignment
\end{itemize}
They are used to \textbf{infer} lambda type.

\subsection*{Type Inference Rules}
\begin{itemize}
	\item \textbf{single possible target type}\\
\textit{	The lambda expression infers its type from the corresponding parameter on the functional interface}
	\item \textbf{several possible types can be inferred}, all belong to the same inheritance tree\\
\textit{	the most specific type is inferred}
\item \textbf{several possible types, none of them is the most specific}\\
\textit{compile error!}
	
\end{itemize}

\section{Use of External values by Lambda}

As functional programming is about transiton from one \textbf{immutable} value to another one, hence:
\begin{itemize}
	\item external values have to have similar properties
	\item they must be \textbf{effectively} final
	\textit{the external variable used by lambda need not to be declared as final as long as it is not \textit{reassigned} later in the code }
	
\end{itemize}
Examples:\\
1. This compiles:
\begin{verbatim}
	String name = "Joe";
	FunctInt.do(input -> "hi " + name);
\end{verbatim}

2. This not:
\begin{verbatim}
	String name = "Joe";
	name = "Kate"; // NOT effectively final!
	FuncInt.do("Hi " + name);
\end{verbatim}
Compile error - variable \textit{name} is reassigned, hence not effectively final.

\section{Lambda Graphically}
\begin{verbatim}
	FunctInt fi = a -> b;
\end{verbatim}

Graphically equivalent:
\begin{verbatim}
a -> FunctInt -> b
\end{verbatim}

\section{Core Functional Interfaces}

Functional interface - an interface, which contains exactly one \textbf{abstract} method, and which is intended to support lambda expressions. Predefined functional interfaces (part of java API):
\begin{itemize}
	\item \textbf{Predicate}$\textless$ T$\textgreater$ , T  $\rightarrow$ boolean
	\item \textbf{Consumer}$\textless$T$\textgreater$, T  $\rightarrow$ void, \textbf{accept()}
	\item \textbf{Function}$\textless$T, R$\textgreater$, T $\rightarrow$ R, \textbf{apply()}
	\item \textbf{Supplier}$\textless$T$\textgreater$, () $\rightarrow$ T
	\item \textbf{UnaryOperator}$\textless$T$\textgreater$, T $\rightarrow$ T
	\item  \textbf{BinaryOperator}$\textless$T$\textgreater$, (T, T)  $\rightarrow$ T
\end{itemize}

\section{Custom Functional Interfaces}
\begin{itemize}
	\item require \textbf{@FunctionalInterface} annotation to be applied
	\item  the annotation signals that the interface \textbf{is intended} to use for lambda expression
	\item annotation compels javac to check whether the interface meets the criteria to be a functional interface. \textbf{helpful by refactoring!}
	\item just \textbf{single method} in an interface \textbf{doesn't make it a functional interface!}
	\begin{itemize}
		\item \textit{Comparable}\\
		The author explanation - because functions are not comparable (have no fieldsm no states). \textbf{I'm not sure, that this is good explanation}
		\item \textit{Closable}\\
		Has to do with resources, which opens and closes. Clearly - they mutate, hence this is not \textbf{pure function}.
	\end{itemize}
\end{itemize}

\section{Method References}
It's common idiom to call a method on method paramether:
\begin{verbatim}
void someMethod(par){
  par.call();
}
\end{verbatim}
using lambda:
\begin{verbatim}
a -> a.call();
\end{verbatim}

\textbf{Abbraviated syntax:}
\begin{verbatim}
A :: call
\end{verbatim}
\textbf{Pay attention, that parameter is capitalised}. This coresponds to athe pattern:
\begin{verbatim}
Classname :: methodName
\end{verbatim}
Brackets are ommited, because \textbf{it's not a method call, but an equivalent of lambda expression.}
\subsection{Applications}
\subsubsection*{Calling a Constructor}
Using lambda:
\begin{verbatim}
(par1, par2) -> new SomeClass(par1, par2);
\end{verbatim}
Using method references:
\begin{verbatim}
SomeClass :: new
\end{verbatim}

\subsubsection*{Instantiate an Array}
\begin{verbatim}
String[] :: new;
\end{verbatim}




\chapter{Aggregate Operations (streams)}
\section{Motivation}
\begin{itemize}
	\item reduces boilerplate code
	\item adds parallelism
\end{itemize}

\section{for-loop vs stream}
This is \textbf{external iteration}:
\begin{itemize}
	\item calls constructor $\rightarrow$ iterator(),
	\item check next $\rightarrow$ hasNext()	
	\item take next $\rightarrow$ next(), nextInt(), asf..
\end{itemize}

Streams are \textbf{internal} iterations invoked by calling \textbf{stream()}. 

\section{Stream methods}
There are two types of stream methods:
\begin{itemize}
	\item lazy, they \textbf{return another stream}.
	\begin{itemize}
		\item  .filter(a $\rightarrow$ b), b $\subseteq$ a
		\item .map(element  $\rightarrow$ mapFunc());
		\item .flatMap(ListOfLists  $\rightarrow$ concatenated\_lists)
	\end{itemize}
	 
	\item  eager, they \textbf{return a value or void}
 	\begin{itemize}
 		\item .count
 		\item  .collectToList(), ..ToSet(), asf..
 		\item .max(), .min()
 		\item .reduce(initVal, (acc, item) -> func(acc, item))
 	\end{itemize}
\end{itemize}

\section{Ordering}
\textit{Encounter order} - the order streamed items appears. Depends on source data and operationson Stream:
\begin{itemize}
	\item Collection with a defined order\\
	 - \textit{the order is preserved}.
	 \item unorder Collection\\
	 - \textit{undefined order}
	 \item the order is propagated through intermediate operations
\end{itemize}

\section{Collectors}
\textbf{.collect(toList()), .collect(toSet())} are just some examples. All collectors to be found in \textit{java.util.stream.Collectors} class; Appropriate implementation (specific type) is picking under the hood.In order to specify the type explicitly pass a constructor as an argument, f.i):
\begin{verbatim}
stream.collect(toCollection(BinaryTree::new));
\end{verbatim}
Can be used to get a single value, too:
\begin{verbatim}
stream.collect(maxBy(comparing(someValue)));
\end{verbatim}
The same way follows using minBy(); Some other applications are:
\begin{itemize}
	\item  \textbf{partitioning and grouping}, p. 64-67. This operations use partitionBy() and groupBy() \textit{Collector}
	\item \textbf{joining(...)} returns some list converted into single string.
\end{itemize}

\section{Patterns \& Idioms Using Aggregate operations}

\subsection*{Filter Pattern}
Traditionally:
\begin{verbatim}
  for(item : List){
    if(conditionOn(item))
      filteredList.add(item);
  }
\end{verbatim}
With aggregate methods:
\begin{verbatim}
  FilteredList fl = List.stream()
                        .filter(item -> conditionOnItem())
                        .collect(toList();)
\end{verbatim}

\subsection*{Reduce Pattern}

Traditionally:
\begin{verbatim}
  var accu = initVal;
  for(item : List){
    combine(accu, item);
  }
\end{verbatim}

Aggregate version:
\begin{verbatim}
  .reduce(initVal, (acc, item) -> func(acc, item));
\end{verbatim}
'func' is of BinaryOperator type - (T, T) $\rightarrow$ T.

When initVal is missing, then first two items are used instead.

\chapter{Data Parallelism}
\section{Intro}
\subsection{Notions}
\subsection*{Concurrency}
More than one task is done at the same time exploiting \textbf{processor time slices}.

\subsection*{Parallelism}
Splits a task in couple of chunks, each assigned to a different processor core, then chunk results are combined into single final result.

\subsection*{Task Pararellism}
Each individual thread of execution can do totally different task.

\section{Impact on Performance}
Depends on:
\begin{itemize}
	\item size, usually
	\begin{itemize}
		\item \textless  100 $\rightarrow$ \textbf{serial} execution is faster
		\item \sim100 $ \rightarrow$ \textbf{both} equally fast
		\item \textgreater 100 $\rightarrow$ \textbf{parallel}  execution is faster
		\end{itemize}
	Those results are due the overhead of decoposing the problem and merging the result.
	\item source data structure
	\begin{itemize}
		\item \textbf{ArrayList, array, Stream.ranges()} are \textbf{cheap} to split
		\item costs of splitting \textbf{HashSet,, TreeSet} is \textbf{acceptable}
		\item \textbf{LinkedList} is \textbf{expensive} to split, usually O(n)
		\item \textbf{Streams.iterate, BufferedReader.lines} are \textbf{hard to estimate} - unknown length at the beginning.
	\end{itemize}
	\item primitives are faster to operate on than boxed values
	\item cost per element
	\begin{itemize}
		\item the more expensive execution of single element, the more likely performance increase
	\end{itemize}
    \item \textbf{stateless} are faster than \textbf{stateful} no need to maintain state
    \begin{itemize}
    	\item stateless - \textbf{.map, .flatmap, .filter}
    	\item statefull - \textbf{.sorted, .distinct, .limit}
    \end{itemize}
\end{itemize}
Exact numbers can vary on different machines.

\section{Parallel Stream Operations}
\textit{.parallelStream()} - parallel version of stream;
\textit{.parallel()} - makes a stream parallel at custom point in method chain.

\section{Caveats}
\textbf{The use of locks can lead to nondeterministic deadlocks!}

\subsection{Parallel .reduce()}
\begin{itemize}
	\item initVal must be the \textbf{identity} of combining function \textit{(0 for adding, 1 for multiplying, asf)}
	\item combining function must be \textbf{associative} \textit{the order of execution doesn't matter}.
\end{itemize}

\section{Arrays}
Some methods:
\begin{itemize}
	\item \textit{parallelPrefix}\\
	- calculates totas given an arbitrary function
	\item \textit{parallelSetAll}\\
	- updates values using lambda
	\item \textit{parallelSort}
\end{itemize}

\subsection*{Example}
\begin{verbatim}
int[] arrayInitialiser(int size){
  int[] values = new int[size];
  for(i = 0; i < values.length; i++){
    int[i] = i;
  }
  return values;
}
\end{verbatim}
Parallel:
\begin{verbatim}
int[] parallelArrayinitialiser(int size){
  int[] values = new int[size];
  Arrays,setAllParalel(values, i -> i);
  return values;
}
\end{verbatim}

Application of \textit{parallelPrefix()}. \textbf{simplemovingAverage} It takes 'rolling window' of n array items an replace values with an average of n previous values:
\begin{verbatim}
double[] simplemovingAverage(double[] values, int size){
  double[] sums = Arays.copyOf(values, values.length);
  
  //new array holds runnung totals of the sums so far. Hence, sum of last n-items will be the difference between sum[i] and sum[i - n].
  // sum[i - n] is hoeld in prefix. 
  Arrays.parallelPrefix(sums, Double :: sum);
  int start = n - 1;
  return IntStream.range(start, sums.length)
                  .mapToDouble(i -> {
                    // 0 assigned to prefix initially, as start - n equals (n - 1) - n = -1 out of the array boundary
                    double prefix = i == start? 0 : sums;
                    return (sum[i] - prefix) / 2;
                  }
                  .toArray();
                  )
}

Is cleaner code possible?
\end{verbatim}

\chapter{Utilities}
\section{Scanner}
Parses primitive types and string using regular expressions. Breaks an input into tokens using whitespace as a default delimiter. Custom delimiter can be specified by useDelimiter(Pattern pattern). Pattern is a compiled )representation of a regular expression.(see: Docs)\\
close() frees resources which implement Closeable (see: \textit{Docs, Specs}).\\
Example:
\begin{verbatim}
import java.util.scanner
.....
Scanner sc = new Scanner(System.in) \\System.in specifies scanner's input
if(sc.hasNextInt())
	int i = sc.nextInt();

if(sc.hasNext())
	String a = sc.next();
    ...
    sc.close();
\end{verbatim}

\subsubsection{Key Points:}
\begin{itemize}
\item parses primitives and Strings
\item nextInt(), nextLong(), nextBool(), next()...
\item delimiter - whitespace (default)
\item read object must implement \textbf{Readable}
\item \textbf{must be \textcolor{red}{closed} to release resources}
\item \textcolor{red}{\textbf{not safe for multithreading!}}
\end{itemize}

\chapter{Antipatterns, Code Smells}
\section{AutoBoxing, Unboxing}
This is not recommended because there is no point to force autoboxing:
\begin{verbatim}
Integer i = 5;
\end{verbatim}
Better:
\begin{verbatim}
Integer i = Integer.valueOf(5);
\end{verbatim}
--------------------------------------------------------
Forced unboxing is also not recommended:
\begin{verbatim}
Integer a = Integer.valueOf(1);
int b = 2;
int c = a + b;
\end{verbatim}
Better:
\begin{verbatim}
Integer a = Integer.valueOf(1);
int b = 2;
int c = a + b.intValue();
\end{verbatim}

\chapter{Docs, Specs}
\begin{itemize}
\item Oracle JDK 9 Documentation\\
\url{https://docs.oracle.com/javase/9/}
\item The JavaÂ® Language Specification\\
\url{https://docs.oracle.com/javase/specs/jls/se9/html/index.html}
\end{itemize}

\section{Java Doc}
\begin{itemize}
\item Pattern - \url{https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}
\item Scanner - \url{https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html}
\end{itemize}
\end{document}
